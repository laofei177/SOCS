#!/usr/bin/env python# nuson-SOCS: Northumbria University Sonification Network: Self Organized Criticality Sonification# trafficSender.py is part of the nuson-SOCS project.# 2010-2016. Original script written by Jonathan Christison, updated and extended# by Paul Vickersimport math, socket, threading, sys, logging, Queue, OSC, time, glob, csv, pickle, argparse# Define command line argumentsparser = argparse.ArgumentParser()parser.add_argument("-t", "--time", action='store', type=float, default=1.0, 					help="Time interval between messages in s. Default is 1.0 s." )parser.add_argument("-w", "--walk", action='store', type=int, default = sys.maxsize,					help="Slow down to walking pace (1 s intervals) at record number" +					" indicated by this argument. Default is sys.maxsize which means" +					" never slow down.")parser.add_argument("-f", "--first", action='store', type=int, default = 1,					help="Ignore all records before 'first'. Default is 1.")parser.add_argument("-l", "--last", action='store', type=int, default = sys.maxsize,					help="Ignore all recordas after 'last'. Default is sys.maxsize.")parser.add_argument("-a", "--absolute", action='store_true', default=False,					help="Use absolute values of log returns. Default is signed log returns.")parser.add_argument("-s", "--square", action='store_true', default=False,					help="Square the log return values. Useful when listening to data at" +					" high speed to make spikes more salient. If the log return is" +					" negative this argument will negate the square. E.g., -2 becomes -4." +					" If the '-a' atttribute is set, then sqaures will all be positive.")args = parser.parse_args()'''-------Globals-----'''LOG_FILENAME = 'debug.log'logging.basicConfig(filename=LOG_FILENAME,level=logging.DEBUG)csvfiles = glob.glob('*.csv')packetdata = []logreturns = []class PacketP(object):			def __init__(self, sentbytes, sentpackets, receivedbytes, receivedpackets):		self.sentbytes = sentbytes		self.sentpackets = sentpackets		self.receivedbytes = receivedbytes		self.receivedpackets = receivedpackets			def getall(self):		return Company.name, Company.address, Company.postcode, Company.website, Company.email, Company.telephone	class LogReturn(object):	def __init__(self, sentbytes, sentpackets, receivedbytes, receivedpackets, sendrecvbytes):		#, sentbytesO, sentpacketsO, receivedbytesO, receivedpacketsO):		self.sentbytes = sentbytes		self.sentpackets = sentpackets		self.receivedbytes = receivedbytes		self.receivedpackets = receivedpackets		self.sendrecvbytes = sendrecvbytes		#self.sentbytesO = sentbytesO		#self.sentpacketsO = sentpacketsO		#self.receivedbytesO = self.receivedbytesO		#self.receivedpacketsO = receivedpacketsO'''-------Ticker------'''class Timer(threading.Thread):	def __init__(self):		threading.Thread.__init__(self)		self.event = threading.Event()	def run(self):		while not self.event.is_set():			tick()			#Get first argument as tick time eg. 0.1ms, 2.0s etc			#If no argument supplied default to 1s tick			#if len(sys.argv) == 1:			#	self.event.wait(1.0)			#else:			#	self.event.wait(float(sys.argv[1]))			self.event.wait(args.time)	def stop(self):		self.event.set() '''--------TCP Server-----'''class TcpServer(threading.Thread):	def __init__(self, queue):		threading.Thread.__init__(self)		self.HOST = '127.0.0.1'    #we are the host		self.PORT = 1280    #arbitrary port not currently in use		self.ADDR = (self.HOST, self.PORT)    #we need a tuple for the address		self.BUFSIZE = 4096    #reasonably sized buffer for data 		self.__queue = queue		self.serv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)     		 		##bind our socket to the address		self.serv.bind((self.ADDR))    #the double parens are to create a tuple with one element		self.serv.listen(5)    #5 is the maximum number of queued connections we'll allow	def run(self):		conn,addr = self.serv.accept() #accept the connection			LogRs = self.__queue.get()				#self.message.append(self.__queue.get())				#while 1:			#self.LogRs = self.__queue.get()		ctr =1 		for LogR in LogRs:			if ctr >= args.first and ctr <= args.last:				self.message = OSC.OSCMessage("/test")				self.message.setAddress("/foo/play")				self.message.append(logVal(LogR.sentbytes))				self.message.append(logVal(LogR.sentpackets))				self.message.append(logVal(LogR.receivedbytes))				self.message.append(logVal(LogR.receivedpackets))				self.message.append(LogR.sendrecvbytes)				print "Sending:'" + "[" +str(ctr)+"]"+ str(self.message) + "'"				conn.send(self.message.getBinary())					if ctr < args.walk:					time.sleep(args.time)				else:					time.sleep(1)					ctr+=1						conn.close()	 def logReturn(Last, Current):	logR = math.log1p(Current) - math.log1p(Last)#	if args.unsquared:#		return (logR)#	else:#		return (logR*logR)	return (logR)	def logVal(logR):	result = logR	if args.square:		result = result * result		if logR < 0:			result = -result	if args.absolute:		result = math.fabs(result)	return (result)queue = Queue.Queue(0)TcpServer(queue).start()if not glob.glob('*.pickle'):	for file in csvfiles:		spamReader = csv.reader(open(file, 'rb'), skipinitialspace=True, delimiter=' ')		for row in spamReader:			print str(row)			packetdata.append(PacketP(row[1], row[2], row[5], row[6]))			#print "Adding row: " +  str(len(packetdata))			sys.stdout.write("\rReading row: %d" % len(packetdata))			sys.stdout.flush()	print "\nRows read in: " +  str(len(packetdata))	for i in range(len(packetdata)):		if i < len(packetdata)-1:			sys.stdout.write("\rCalculating log returns for: %d" % i)			sys.stdout.flush()			#print "\nPDLength: " + str(len(packetdata))			logreturns.append(			LogReturn(			logReturn(float(packetdata[i].sentbytes), float(packetdata[i+1].sentbytes)),			logReturn(float(packetdata[i].sentpackets), float(packetdata[i+1].sentpackets)),			logReturn(float(packetdata[i].receivedbytes), float(packetdata[i+1].receivedbytes)),			logReturn(float(packetdata[i].receivedpackets), float(packetdata[i+1].receivedpackets)),			(float(packetdata[i].sentbytes) + float(packetdata[i].receivedbytes))					))			#del packetdata[i]			del packetdata[i+1]	pickle.dump( logreturns, open ("logreturns.pickle", "wb"))	del packetdata[:]else:	print "Pickle detected loading that instead..."	pickles = glob.glob('*.pickle')	for pickled in pickles:		logreturns = pickle.load(open(pickled))		'''for PacketP in packetdata:	print "------------------------"	print "BSent: " + PacketP.sentbytes	print "NPSent: " + PacketP.sentpackets	print "BRecv: " + PacketP.receivedbytes	print "BPRecv:" + PacketP.receivedpackets'''queue.put(logreturns)for LogR in logreturns:	#time.sleep(1)	print "LogRsize: " + str(len(logreturns))	print "BSentLogR: " + str(LogR.sentbytes)	print "NPSentLogR: " + str(LogR.sentpackets)	print "BRecvLogR: " + str(LogR.receivedbytes)	print "NPRecvLogR: " + str(LogR.receivedpackets)	print "BSentRecvLogR: " + str(LogR.sendrecvbytes)	